// This file was auto-generated by Fern from our API Definition.

package fluidstack

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/fluidstackio/fluidstack-go-sdk/internal"
	time "time"
)

type CreateInstanceRequest struct {
	// The custom name of the instance.
	Name *string `json:"name,omitempty" url:"-"`
	// The GPU type of the instance.
	GpuType GpuType `json:"gpu_type" url:"-"`
	// The number of GPUs to attach to the instance.
	GpuCount *int `json:"gpu_count,omitempty" url:"-"`
	// The SSH key name to add to the instance. This SSH key is used to connect to the instance.
	SshKey string `json:"ssh_key" url:"-"`
	// The operating system label used to create the instance.
	OperatingSystemLabel *CreateInstanceRequestOperatingSystemLabel `json:"operating_system_label,omitempty" url:"-"`
	// The region in which to create the instance.
	Region *Region `json:"region,omitempty" url:"-"`
	// The volumes attached to the instance.
	Volumes []*VolumeInstanceResponse `json:"volumes,omitempty" url:"-"`
}

type InstancesListRequest struct {
	Page *int `json:"-" url:"page,omitempty"`
	// Include failed instances. Default is False.
	IncludeFailedInstances *bool `json:"-" url:"include_failed_instances,omitempty"`
}

type ConfigurationInstanceResponse struct {
	Id EntityId `json:"id" url:"id"`
	// The GPU model of the configuration.
	GpuModel *GpuModelResponse `json:"gpu_model,omitempty" url:"gpu_model,omitempty"`
	// The CPU model of the configuration.
	CpuModel *string `json:"cpu_model,omitempty" url:"cpu_model,omitempty"`
	// The number of GPUs in the configuration.
	GpuCount int `json:"gpu_count" url:"gpu_count"`
	// The number of CPUs in the configuration.
	CpuCount int `json:"cpu_count" url:"cpu_count"`
	// The size of NVMe in the configuration.
	NvmeStorageSizeGb int `json:"nvme_storage_size_gb" url:"nvme_storage_size_gb"`
	// The amount of RAM memory in the configuration.
	MemorySizeGb                     float64 `json:"memory_size_gb" url:"memory_size_gb"`
	EstimatedProvisioningTimeMinutes *int    `json:"estimated_provisioning_time_minutes,omitempty" url:"estimated_provisioning_time_minutes,omitempty"`
	Region                           Region  `json:"region" url:"region"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConfigurationInstanceResponse) GetId() EntityId {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *ConfigurationInstanceResponse) GetGpuModel() *GpuModelResponse {
	if c == nil {
		return nil
	}
	return c.GpuModel
}

func (c *ConfigurationInstanceResponse) GetCpuModel() *string {
	if c == nil {
		return nil
	}
	return c.CpuModel
}

func (c *ConfigurationInstanceResponse) GetGpuCount() int {
	if c == nil {
		return 0
	}
	return c.GpuCount
}

func (c *ConfigurationInstanceResponse) GetCpuCount() int {
	if c == nil {
		return 0
	}
	return c.CpuCount
}

func (c *ConfigurationInstanceResponse) GetNvmeStorageSizeGb() int {
	if c == nil {
		return 0
	}
	return c.NvmeStorageSizeGb
}

func (c *ConfigurationInstanceResponse) GetMemorySizeGb() float64 {
	if c == nil {
		return 0
	}
	return c.MemorySizeGb
}

func (c *ConfigurationInstanceResponse) GetEstimatedProvisioningTimeMinutes() *int {
	if c == nil {
		return nil
	}
	return c.EstimatedProvisioningTimeMinutes
}

func (c *ConfigurationInstanceResponse) GetRegion() Region {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *ConfigurationInstanceResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConfigurationInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfigurationInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfigurationInstanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfigurationInstanceResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateInstanceResponse struct {
	Id                   string                                      `json:"id" url:"id"`
	Name                 string                                      `json:"name" url:"name"`
	GpuType              GpuType                                     `json:"gpu_type" url:"gpu_type"`
	OperatingSystemLabel *CreateInstanceResponseOperatingSystemLabel `json:"operating_system_label,omitempty" url:"operating_system_label,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateInstanceResponse) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CreateInstanceResponse) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateInstanceResponse) GetGpuType() GpuType {
	if c == nil {
		return ""
	}
	return c.GpuType
}

func (c *CreateInstanceResponse) GetOperatingSystemLabel() *CreateInstanceResponseOperatingSystemLabel {
	if c == nil {
		return nil
	}
	return c.OperatingSystemLabel
}

func (c *CreateInstanceResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateInstanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateInstanceResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateInstanceResponseOperatingSystemLabel struct {
	SupportedOperatingSystem SupportedOperatingSystem
	String                   string

	typ string
}

func (c *CreateInstanceResponseOperatingSystemLabel) GetSupportedOperatingSystem() SupportedOperatingSystem {
	if c == nil {
		return ""
	}
	return c.SupportedOperatingSystem
}

func (c *CreateInstanceResponseOperatingSystemLabel) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreateInstanceResponseOperatingSystemLabel) UnmarshalJSON(data []byte) error {
	var valueSupportedOperatingSystem SupportedOperatingSystem
	if err := json.Unmarshal(data, &valueSupportedOperatingSystem); err == nil {
		c.typ = "SupportedOperatingSystem"
		c.SupportedOperatingSystem = valueSupportedOperatingSystem
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateInstanceResponseOperatingSystemLabel) MarshalJSON() ([]byte, error) {
	if c.typ == "SupportedOperatingSystem" || c.SupportedOperatingSystem != "" {
		return json.Marshal(c.SupportedOperatingSystem)
	}
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateInstanceResponseOperatingSystemLabelVisitor interface {
	VisitSupportedOperatingSystem(SupportedOperatingSystem) error
	VisitString(string) error
}

func (c *CreateInstanceResponseOperatingSystemLabel) Accept(visitor CreateInstanceResponseOperatingSystemLabelVisitor) error {
	if c.typ == "SupportedOperatingSystem" || c.SupportedOperatingSystem != "" {
		return visitor.VisitSupportedOperatingSystem(c.SupportedOperatingSystem)
	}
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type EntityId = string

type GpuModelResponse struct {
	// The FluidStack unique name of the GPU model.
	Name string `json:"name" url:"name"`
	// Memory capacity of the GPU in gigabytes.
	MemorySizeGb *int `json:"memory_size_gb,omitempty" url:"memory_size_gb,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GpuModelResponse) GetName() string {
	if g == nil {
		return ""
	}
	return g.Name
}

func (g *GpuModelResponse) GetMemorySizeGb() *int {
	if g == nil {
		return nil
	}
	return g.MemorySizeGb
}

func (g *GpuModelResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GpuModelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GpuModelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GpuModelResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GpuModelResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type InstanceResponse struct {
	// The unique identifier of the instance.
	Id string `json:"id" url:"id"`
	// The current status of the instance.
	Status *InstanceStatus `json:"status,omitempty" url:"status,omitempty"`
	// The username used to connect to the instance. For example, to connect to the instance via SSH, use: "ssh -i <path/to/private/key> <username>@<ip_address>".
	Username *string `json:"username,omitempty" url:"username,omitempty"`
	// The SSH port used to connect to the instance.
	SshPort *string `json:"ssh_port,omitempty" url:"ssh_port,omitempty"`
	// The names of the SSH keys used to login to the instance.
	SshKeys []string `json:"ssh_keys,omitempty" url:"ssh_keys,omitempty"`
	// The IP address of the instance.
	IpAddress *string `json:"ip_address,omitempty" url:"ip_address,omitempty"`
	// The name provided when the instance was created.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The current hourly price of the instance per processor based on its current status.
	CurrentGpuHrCost *float64 `json:"current_gpu_hr_cost,omitempty" url:"current_gpu_hr_cost,omitempty"`
	// The configuration used to create the instance.
	Configuration *ConfigurationInstanceResponse `json:"configuration,omitempty" url:"configuration,omitempty"`
	// The creation date and time of the instance.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The volumes attached to the instance.
	Volumes []*VolumeInstanceResponse `json:"volumes,omitempty" url:"volumes,omitempty"`
	// The operating system used to create the instance.
	OperatingSystemLabel *InstanceResponseOperatingSystemLabel `json:"operating_system_label,omitempty" url:"operating_system_label,omitempty"`
	// The email of the user that owns the instance.
	UserEmail *string `json:"user_email,omitempty" url:"user_email,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InstanceResponse) GetId() string {
	if i == nil {
		return ""
	}
	return i.Id
}

func (i *InstanceResponse) GetStatus() *InstanceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InstanceResponse) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InstanceResponse) GetSshPort() *string {
	if i == nil {
		return nil
	}
	return i.SshPort
}

func (i *InstanceResponse) GetSshKeys() []string {
	if i == nil {
		return nil
	}
	return i.SshKeys
}

func (i *InstanceResponse) GetIpAddress() *string {
	if i == nil {
		return nil
	}
	return i.IpAddress
}

func (i *InstanceResponse) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InstanceResponse) GetCurrentGpuHrCost() *float64 {
	if i == nil {
		return nil
	}
	return i.CurrentGpuHrCost
}

func (i *InstanceResponse) GetConfiguration() *ConfigurationInstanceResponse {
	if i == nil {
		return nil
	}
	return i.Configuration
}

func (i *InstanceResponse) GetCreatedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InstanceResponse) GetVolumes() []*VolumeInstanceResponse {
	if i == nil {
		return nil
	}
	return i.Volumes
}

func (i *InstanceResponse) GetOperatingSystemLabel() *InstanceResponseOperatingSystemLabel {
	if i == nil {
		return nil
	}
	return i.OperatingSystemLabel
}

func (i *InstanceResponse) GetUserEmail() *string {
	if i == nil {
		return nil
	}
	return i.UserEmail
}

func (i *InstanceResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InstanceResponse) UnmarshalJSON(data []byte) error {
	type embed InstanceResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InstanceResponse(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InstanceResponse) MarshalJSON() ([]byte, error) {
	type embed InstanceResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewOptionalDateTime(i.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InstanceResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The operating system used to create the instance.
type InstanceResponseOperatingSystemLabel struct {
	SupportedOperatingSystem SupportedOperatingSystem
	String                   string

	typ string
}

func (i *InstanceResponseOperatingSystemLabel) GetSupportedOperatingSystem() SupportedOperatingSystem {
	if i == nil {
		return ""
	}
	return i.SupportedOperatingSystem
}

func (i *InstanceResponseOperatingSystemLabel) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InstanceResponseOperatingSystemLabel) UnmarshalJSON(data []byte) error {
	var valueSupportedOperatingSystem SupportedOperatingSystem
	if err := json.Unmarshal(data, &valueSupportedOperatingSystem); err == nil {
		i.typ = "SupportedOperatingSystem"
		i.SupportedOperatingSystem = valueSupportedOperatingSystem
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InstanceResponseOperatingSystemLabel) MarshalJSON() ([]byte, error) {
	if i.typ == "SupportedOperatingSystem" || i.SupportedOperatingSystem != "" {
		return json.Marshal(i.SupportedOperatingSystem)
	}
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InstanceResponseOperatingSystemLabelVisitor interface {
	VisitSupportedOperatingSystem(SupportedOperatingSystem) error
	VisitString(string) error
}

func (i *InstanceResponseOperatingSystemLabel) Accept(visitor InstanceResponseOperatingSystemLabelVisitor) error {
	if i.typ == "SupportedOperatingSystem" || i.SupportedOperatingSystem != "" {
		return visitor.VisitSupportedOperatingSystem(i.SupportedOperatingSystem)
	}
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InstanceStatus string

const (
	InstanceStatusRunning      InstanceStatus = "running"
	InstanceStatusStarting     InstanceStatus = "starting"
	InstanceStatusPending      InstanceStatus = "pending"
	InstanceStatusFailed       InstanceStatus = "failed"
	InstanceStatusTerminated   InstanceStatus = "terminated"
	InstanceStatusStopped      InstanceStatus = "stopped"
	InstanceStatusStopping     InstanceStatus = "stopping"
	InstanceStatusProvisioning InstanceStatus = "provisioning"
)

func NewInstanceStatusFromString(s string) (InstanceStatus, error) {
	switch s {
	case "running":
		return InstanceStatusRunning, nil
	case "starting":
		return InstanceStatusStarting, nil
	case "pending":
		return InstanceStatusPending, nil
	case "failed":
		return InstanceStatusFailed, nil
	case "terminated":
		return InstanceStatusTerminated, nil
	case "stopped":
		return InstanceStatusStopped, nil
	case "stopping":
		return InstanceStatusStopping, nil
	case "provisioning":
		return InstanceStatusProvisioning, nil
	}
	var t InstanceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InstanceStatus) Ptr() *InstanceStatus {
	return &i
}

type ListInstanceResponse struct {
	// The unique identifier of the instance.
	Id string `json:"id" url:"id"`
	// The current status of the instance.
	Status *InstanceStatus `json:"status,omitempty" url:"status,omitempty"`
	// The username used to connect to the instance. For example, to connect to the instance via SSH, use: "ssh -i <path/to/private/key> <username>@<ip_address>".
	Username *string `json:"username,omitempty" url:"username,omitempty"`
	// The SSH port used to connect to the instance.
	SshPort *string `json:"ssh_port,omitempty" url:"ssh_port,omitempty"`
	// The names of the SSH keys used to login to the instance.
	SshKeys []string `json:"ssh_keys,omitempty" url:"ssh_keys,omitempty"`
	// The IP address of the instance.
	IpAddress *string `json:"ip_address,omitempty" url:"ip_address,omitempty"`
	// The name provided when the instance was created.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The current hourly price of the instance per processor based on its current status.
	CurrentGpuHrCost *float64 `json:"current_gpu_hr_cost,omitempty" url:"current_gpu_hr_cost,omitempty"`
	// The configuration used to create the instance.
	Configuration *ConfigurationInstanceResponse `json:"configuration,omitempty" url:"configuration,omitempty"`
	// The creation date and time of the instance.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The volumes attached to the instance.
	Volumes []*VolumeInstanceResponse `json:"volumes,omitempty" url:"volumes,omitempty"`
	// The operating system used to create the instance.
	OperatingSystemLabel *ListInstanceResponseOperatingSystemLabel `json:"operating_system_label,omitempty" url:"operating_system_label,omitempty"`
	// The email of the user that owns the instance.
	UserEmail *string `json:"user_email,omitempty" url:"user_email,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListInstanceResponse) GetId() string {
	if l == nil {
		return ""
	}
	return l.Id
}

func (l *ListInstanceResponse) GetStatus() *InstanceStatus {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *ListInstanceResponse) GetUsername() *string {
	if l == nil {
		return nil
	}
	return l.Username
}

func (l *ListInstanceResponse) GetSshPort() *string {
	if l == nil {
		return nil
	}
	return l.SshPort
}

func (l *ListInstanceResponse) GetSshKeys() []string {
	if l == nil {
		return nil
	}
	return l.SshKeys
}

func (l *ListInstanceResponse) GetIpAddress() *string {
	if l == nil {
		return nil
	}
	return l.IpAddress
}

func (l *ListInstanceResponse) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *ListInstanceResponse) GetCurrentGpuHrCost() *float64 {
	if l == nil {
		return nil
	}
	return l.CurrentGpuHrCost
}

func (l *ListInstanceResponse) GetConfiguration() *ConfigurationInstanceResponse {
	if l == nil {
		return nil
	}
	return l.Configuration
}

func (l *ListInstanceResponse) GetCreatedAt() *time.Time {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *ListInstanceResponse) GetVolumes() []*VolumeInstanceResponse {
	if l == nil {
		return nil
	}
	return l.Volumes
}

func (l *ListInstanceResponse) GetOperatingSystemLabel() *ListInstanceResponseOperatingSystemLabel {
	if l == nil {
		return nil
	}
	return l.OperatingSystemLabel
}

func (l *ListInstanceResponse) GetUserEmail() *string {
	if l == nil {
		return nil
	}
	return l.UserEmail
}

func (l *ListInstanceResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListInstanceResponse) UnmarshalJSON(data []byte) error {
	type embed ListInstanceResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = ListInstanceResponse(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListInstanceResponse) MarshalJSON() ([]byte, error) {
	type embed ListInstanceResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
	}{
		embed:     embed(*l),
		CreatedAt: internal.NewOptionalDateTime(l.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (l *ListInstanceResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The operating system used to create the instance.
type ListInstanceResponseOperatingSystemLabel struct {
	SupportedOperatingSystem SupportedOperatingSystem
	String                   string

	typ string
}

func (l *ListInstanceResponseOperatingSystemLabel) GetSupportedOperatingSystem() SupportedOperatingSystem {
	if l == nil {
		return ""
	}
	return l.SupportedOperatingSystem
}

func (l *ListInstanceResponseOperatingSystemLabel) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *ListInstanceResponseOperatingSystemLabel) UnmarshalJSON(data []byte) error {
	var valueSupportedOperatingSystem SupportedOperatingSystem
	if err := json.Unmarshal(data, &valueSupportedOperatingSystem); err == nil {
		l.typ = "SupportedOperatingSystem"
		l.SupportedOperatingSystem = valueSupportedOperatingSystem
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l ListInstanceResponseOperatingSystemLabel) MarshalJSON() ([]byte, error) {
	if l.typ == "SupportedOperatingSystem" || l.SupportedOperatingSystem != "" {
		return json.Marshal(l.SupportedOperatingSystem)
	}
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type ListInstanceResponseOperatingSystemLabelVisitor interface {
	VisitSupportedOperatingSystem(SupportedOperatingSystem) error
	VisitString(string) error
}

func (l *ListInstanceResponseOperatingSystemLabel) Accept(visitor ListInstanceResponseOperatingSystemLabelVisitor) error {
	if l.typ == "SupportedOperatingSystem" || l.SupportedOperatingSystem != "" {
		return visitor.VisitSupportedOperatingSystem(l.SupportedOperatingSystem)
	}
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

type VolumeInstanceResponse struct {
	// The ID of the volume.
	Id EntityId `json:"id" url:"id"`
	// The name of the volume.
	Name string `json:"name" url:"name"`
	// The size of the volume in GB.
	SizeGb int `json:"size_gb" url:"size_gb"`
	// The status of the volume.
	Status *VolumeStatus `json:"status,omitempty" url:"status,omitempty"`
	// The current hourly rate of the volume.
	CostGbHr string `json:"cost_gb_hr" url:"cost_gb_hr"`
	// The creation time of the volume.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The update time of the volume.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VolumeInstanceResponse) GetId() EntityId {
	if v == nil {
		return ""
	}
	return v.Id
}

func (v *VolumeInstanceResponse) GetName() string {
	if v == nil {
		return ""
	}
	return v.Name
}

func (v *VolumeInstanceResponse) GetSizeGb() int {
	if v == nil {
		return 0
	}
	return v.SizeGb
}

func (v *VolumeInstanceResponse) GetStatus() *VolumeStatus {
	if v == nil {
		return nil
	}
	return v.Status
}

func (v *VolumeInstanceResponse) GetCostGbHr() string {
	if v == nil {
		return ""
	}
	return v.CostGbHr
}

func (v *VolumeInstanceResponse) GetCreatedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.CreatedAt
}

func (v *VolumeInstanceResponse) GetUpdatedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.UpdatedAt
}

func (v *VolumeInstanceResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VolumeInstanceResponse) UnmarshalJSON(data []byte) error {
	type embed VolumeInstanceResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VolumeInstanceResponse(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	v.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VolumeInstanceResponse) MarshalJSON() ([]byte, error) {
	type embed VolumeInstanceResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*v),
		CreatedAt: internal.NewOptionalDateTime(v.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(v.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (v *VolumeInstanceResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VolumeStatus string

const (
	VolumeStatusCreating  VolumeStatus = "creating"
	VolumeStatusAttached  VolumeStatus = "attached"
	VolumeStatusAttaching VolumeStatus = "attaching"
	VolumeStatusReady     VolumeStatus = "ready"
	VolumeStatusUnknown   VolumeStatus = "unknown"
	VolumeStatusError     VolumeStatus = "error"
	VolumeStatusDeleted   VolumeStatus = "deleted"
)

func NewVolumeStatusFromString(s string) (VolumeStatus, error) {
	switch s {
	case "creating":
		return VolumeStatusCreating, nil
	case "attached":
		return VolumeStatusAttached, nil
	case "attaching":
		return VolumeStatusAttaching, nil
	case "ready":
		return VolumeStatusReady, nil
	case "unknown":
		return VolumeStatusUnknown, nil
	case "error":
		return VolumeStatusError, nil
	case "deleted":
		return VolumeStatusDeleted, nil
	}
	var t VolumeStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VolumeStatus) Ptr() *VolumeStatus {
	return &v
}

// The operating system label used to create the instance.
type CreateInstanceRequestOperatingSystemLabel struct {
	SupportedOperatingSystem SupportedOperatingSystem
	String                   string

	typ string
}

func (c *CreateInstanceRequestOperatingSystemLabel) GetSupportedOperatingSystem() SupportedOperatingSystem {
	if c == nil {
		return ""
	}
	return c.SupportedOperatingSystem
}

func (c *CreateInstanceRequestOperatingSystemLabel) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreateInstanceRequestOperatingSystemLabel) UnmarshalJSON(data []byte) error {
	var valueSupportedOperatingSystem SupportedOperatingSystem
	if err := json.Unmarshal(data, &valueSupportedOperatingSystem); err == nil {
		c.typ = "SupportedOperatingSystem"
		c.SupportedOperatingSystem = valueSupportedOperatingSystem
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateInstanceRequestOperatingSystemLabel) MarshalJSON() ([]byte, error) {
	if c.typ == "SupportedOperatingSystem" || c.SupportedOperatingSystem != "" {
		return json.Marshal(c.SupportedOperatingSystem)
	}
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateInstanceRequestOperatingSystemLabelVisitor interface {
	VisitSupportedOperatingSystem(SupportedOperatingSystem) error
	VisitString(string) error
}

func (c *CreateInstanceRequestOperatingSystemLabel) Accept(visitor CreateInstanceRequestOperatingSystemLabelVisitor) error {
	if c.typ == "SupportedOperatingSystem" || c.SupportedOperatingSystem != "" {
		return visitor.VisitSupportedOperatingSystem(c.SupportedOperatingSystem)
	}
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}
